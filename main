#include <Adafruit_MotorShield.h>

// Create the motor shield object with the default I2C address
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
// Select which 'port' M1, M2, M3 or M4. In this case, M1
Adafruit_DCMotor *LeftMotor = AFMS.getMotor(4);
Adafruit_DCMotor *RightMotor = AFMS.getMotor(1);

bool linetrack = false;
int buttonPin = 4;
int sl=6;   //sensor left
int sr=7;  //sensor right
int ssr=8;   //outer sensor right
int ssl=9;   //outer sensor left
int svr=0; //sensor value right
int svl=0; //sensor value left
int svvr=0; //outer sensor value right
int svvl=0; //outer sensor value left
int led=13;
int enr=3; 
int enl=5;
int motorspeed=150; //0-255
int vspeed=100;    
int tspeed=255;
int tdelay=2;     
int count = 0; //count the numbers of turn

void setup() {
  // put your setup code here, to run once:
  if (!AFMS.begin()) {         // create with the default frequency 1.6KHz
  // if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz
    Serial.println("Could not find Motor Shield. Check wiring.");
    while (1);
  }
  Serial.begin(9600);           // set up Serial library at 9600 bps
  Serial.println("Setup");
  pinMode(buttonPin, INPUT); 
  pinMode(sl,INPUT);
  pinMode(sr,INPUT);
  LeftMotor->setSpeed(motorspeed);
  RightMotor->setSpeed(motorspeed);
  delay(5000);
  int val = digitalRead(buttonPin); // read input value
}

void loop() {
  // put your main code here, to run repeatedly
  int val = digitalRead(buttonPin); // read input value
  LeftMotor->setSpeed(150);
  RightMotor->setSpeed(150);
  if (val==HIGH){
    Serial.print("ON");
    initialise();
    Serial.println("RUN");
  }
 
  while (linetrack==1){
    linetracking();
    }
  
}

//Universal function

void initialise(){
  //move forward for 2 seconds
  Serial.println("INITIALISE");
  LeftMotor->setSpeed(150);
  LeftMotor->run(FORWARD);
  RightMotor->setSpeed(150);
  RightMotor->run(FORWARD);
  delay(1000);
  linetrack = true;
  //need to add a release here? myMotor->run(RELEASE);
}

void time_delay(){
  unsigned long previousMillis = 0; //store time for second event
  const long interval = 500; //interval for second event
  unsigned long currentMillis = millis(); //conditional that checks whether 2 seconds have passed since last event
  if (currentMillis - previousMillis >= interval) {
    previousMillis = millis();
    //execute a piece of code, every *2 seconds*
   }
}


void linetracking(){
 //Serial.println("LINETRACKING");
 svl=digitalRead(sl);
 svr=digitalRead(sr);
   
  if(svl==LOW && svr==LOW)
  {
  stop(); 
  }
  else if(svl==HIGH   && svr==LOW)
  {
  left(); 
  }
  else if(svl==LOW && svr==HIGH)
   { 
  right(); 
  }
  else if(svl==HIGH && svr==HIGH)
   {
  forward();
  }
}

void forward()
 {
  //adjust the speed here if needed
  LeftMotor->run(FORWARD);
  RightMotor->run(FORWARD);
  Serial.println("FORWARD");
  delay(tdelay);
 } 

void backward()
   {
    LeftMotor->run(BACKWARD);
    RightMotor->run(BACKWARD);
      Serial.println("BACKWARD");
    delay(tdelay);
   }

void right() 
 {
  LeftMotor->setSpeed(225);
  LeftMotor->run(FORWARD);
  RightMotor->setSpeed(25);
  RightMotor->run(FORWARD);
    Serial.println("RIGHT");
  delay(tdelay);
  }


void left() 
 {
  RightMotor->setSpeed(225);
  RightMotor->run(FORWARD);
  LeftMotor->setSpeed(25);
  LeftMotor->run(FORWARD);
  Serial.println("LEFT");
  delay(tdelay); 
}  

void right90() //turn 90 degrees
 {
  //unsigned long current_time = millis(); 
  // Serial.println(current_time);
  // int interval = 2000;
  // while((millis()-current_time) < interval){
  // Serial.println(millis());
  LeftMotor->run(FORWARD);
  RightMotor->run(BACKWARD);
  //time_delay();
 } 

void left90() //turn 90 degrees
 {
  LeftMotor->run(BACKWARD);
  RightMotor->run(FORWARD);
  time_delay();
}  

void stop()
 {
  LeftMotor->run(RELEASE);
  RightMotor->run(RELEASE);
 }

 void turn_left(){
  
  svvr=digitalRead(ssr);
  svvl=digitalRead(ssl);
  
  if(svvl==HIGH   && svvr==HIGH)
  {
  left90();
  count++;
  }

}

void turn_right(){
  svvr=digitalRead(ssr);
  svvl=digitalRead(ssl);
  if(svvl==LOW   && svvr==HIGH)
  {
  right90(); 
  }

}
